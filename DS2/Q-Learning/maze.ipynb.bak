{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 559,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import random as r"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 560,
   "metadata": {},
   "outputs": [],
   "source": [
    "MAZE=[[0,0,1,1,1],\n",
    "      [0,1,1,0,1],\n",
    "      [1,1,1,0,1],\n",
    "      [1,0,1,0,1],\n",
    "      [1,0,1,1,1]]\n",
    "REWARDS_TABLE = [[0,0,1,1,1],\n",
    "                 [0,1,1,0,1],\n",
    "                 [1,1,1,0,1],\n",
    "                 [1,0,1,0,1],\n",
    "                 [100,0,1,1,1]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 561,
   "metadata": {},
   "outputs": [],
   "source": [
    "def init_state_table():\n",
    "    qtable = []\n",
    "    for row in range(len(MAZE)):\n",
    "        for column in range(len(MAZE[row])):\n",
    "            qtable.append(QEntry((row, column)))\n",
    "    return qtable\n",
    "            \n",
    "\n",
    "class QEntry:\n",
    "    def __init__(self, state):\n",
    "        self.state = state\n",
    "        self.up = 0\n",
    "        self.down = 0\n",
    "        self.left = 0\n",
    "        self.right = 0\n",
    "    \n",
    "    def get_state(self):\n",
    "        return self.state\n",
    "    def get_positions(self):\n",
    "        return {\"up\": self.up, \"down\": self.down, \"left\": self.left, \"right\": self.right}\n",
    "    \n",
    "    def update_positions(self, new_positions):\n",
    "        for key, value in new_positions.values():\n",
    "            pass\n",
    "            \n",
    "\n",
    "# Init Q-Table\n",
    "q_table = init_state_table()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 562,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_possible_actions(row_index, column_index):    \n",
    "    possible = {\"up\": False, \"down\": False, \"right\": False, \"left\": False}\n",
    "    #possible = {\"up\": row_index != 0, \"down\": row_index != len(MAZE)-1, \"right\": column_index != 0, \"left\": column_index != len(MAZE[0])-1}    \n",
    "    dir_functions = {\"up\": (lambda: True if MAZE[row_index-1][column_index] == 1 and not row_index == 0 else False),\n",
    "                     \"down\": (lambda: True if MAZE[row_index+1][column_index] == 1 and not row_index == len(MAZE)-1 else False),\n",
    "                     \"right\": (lambda: True if MAZE[row_index][column_index+1] == 1 and not column_index == len(MAZE[row_index])-1 else False),\n",
    "                     \"left\": (lambda: True if MAZE[row_index][column_index-1] == 1 and not column_index == 0 else False)}\n",
    "    for dir,funct in dir_functions.items():\n",
    "        try:\n",
    "            possible[dir] = funct()\n",
    "        except: pass\n",
    "\n",
    "    return possible"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 563,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pick_random_true_key(dictionary):\n",
    "    true_keys = [key for key, value in dictionary.items() if value]\n",
    "    if not true_keys:\n",
    "        return None\n",
    "    return r.choice(true_keys)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 564,
   "metadata": {},
   "outputs": [],
   "source": [
    "# def get_q_entry()\n",
    "\n",
    "def get_next_move_qtable(current_state, dir):\n",
    "    '''\n",
    "    current_state: A tuple containing the coordinates to the old state, (row_index, column_index)\n",
    "    '''\n",
    "\n",
    "    next_state = list(current_state)\n",
    "    match dir:\n",
    "        case \"up\":\n",
    "            next_state[0] = current_state[0] - 1\n",
    "            next_state[1] = current_state[1]\n",
    "        case \"down\":\n",
    "            next_state[0] = current_state[0] + 1\n",
    "            next_state[1] = current_state[1]\n",
    "        case \"left\":\n",
    "            next_state[0] = current_state[0]\n",
    "            next_state[1] = current_state[1] - 1\n",
    "        case \"right\":\n",
    "            next_state[0] = current_state[0]\n",
    "            next_state[1] = current_state[1] + 1\n",
    "        case _:\n",
    "            raise Exception(\"Direction is invalid\")\n",
    "    next_state = tuple(next_state)\n",
    "        \n",
    "    # Find the entry in the q_table that contains the new state\n",
    "    for i in range(len(q_table)):\n",
    "        # print(str(q_table[i].get_state()) + str(next_state))\n",
    "        if q_table[i].get_state() == next_state:\n",
    "            return q_table[i]\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 565,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Bellman Equation\n",
    "alpha = 0.6\n",
    "gamma = 0.7\n",
    "\n",
    "bellman_equation = lambda state, old, next : (1 - alpha) * old + alpha * (REWARDS_TABLE[state[0]][state[1]] + gamma * next)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 566,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"(0, 0){'up': 0, 'down': 0, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(0, 1){'up': 0, 'down': 0.0, 'left': 0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(0, 2){'up': 0, 'down': 0.6, 'left': 0, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(0, 3){'up': 0, 'down': 0, 'left': 0.6, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(0, 4){'up': 0, 'down': 0.6, 'left': 0.6, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(1, 0){'up': 0, 'down': 0.0, 'left': 0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(1, 1){'up': 0, 'down': 0.6, 'left': 0, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(1, 2){'up': 0.6, 'down': 0.6, 'left': 0.6, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(1, 3){'up': 0.0, 'down': 0, 'left': 0.0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(1, 4){'up': 0.6, 'down': 0.6, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(2, 0){'up': 0, 'down': 0.6, 'left': 0, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(2, 1){'up': 0.6, 'down': 0, 'left': 0.6, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(2, 2){'up': 0.6, 'down': 0.6, 'left': 0.6, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(2, 3){'up': 0, 'down': 0, 'left': 0.0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(2, 4){'up': 0.6, 'down': 0.6, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(3, 0){'up': 0.6, 'down': 0.6, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(3, 1){'up': 0.0, 'down': 0, 'left': 0.0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(3, 2){'up': 0.6, 'down': 0.6, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(3, 3){'up': 0, 'down': 0.0, 'left': 0.0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(3, 4){'up': 0.6, 'down': 0.6, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(4, 0){'up': 60.0, 'down': 0, 'left': 0, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(4, 1){'up': 0, 'down': 0, 'left': 0.0, 'right': 0.0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(4, 2){'up': 0.6, 'down': 0, 'left': 0, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(4, 3){'up': 0, 'down': 0, 'left': 0.6, 'right': 0.6}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "\"(4, 4){'up': 0.6, 'down': 0, 'left': 0.6, 'right': 0}\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# MAZE=[[0,0,1,1,1],\n",
    "#       [0,1,1,0,1],\n",
    "#       [1,1,1,0,1],\n",
    "#       [1,0,1,0,1],\n",
    "#       [1,0,1,1,1]]\n",
    "#REWARDS_TABLE = [[0,0,1,1,1],\n",
    "       #          [0,1,1,0,1],\n",
    "             #    [1,1,1,0,1],\n",
    "             #    [1,0,1,0,1],\n",
    "            #     [100,0,1,1,1]]\n",
    "\n",
    "for entry in q_table:\n",
    "    state = entry.get_state()\n",
    "    state_movements = entry.get_positions()\n",
    "    \n",
    "    possible_movements = get_possible_actions(state[0], state[1])\n",
    "    for key, value in possible_movements.items():\n",
    "        if value == True:\n",
    "            old = state_movements[key]\n",
    "            get_possible_actions(state, key)\n",
    "            next_q_obj = get_next_move_qtable(state, key)\n",
    "            next_q = max(list(next_q_obj.get_positions().values()))\n",
    "            state_movements[key] = bellman_equation(state, old, next_q)\n",
    "\n",
    "    display(str(state) + str(state_movements))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 567,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'up': True, 'down': False, 'right': True, 'left': True}"
      ]
     },
     "execution_count": 567,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_possible_actions(2,1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 568,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# bellman_equation = lambda alpha, gamma, reward : (1 - alpha) * q(s,a) + alpha * (reward + gamma * max(q'))\n",
    "\n",
    "# bellman_equation = lambda alpha, gamma, reward : (1 - alpha) * q(s,a) + alpha * (reward + gamma * max(q'))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "dsvenv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.10"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
