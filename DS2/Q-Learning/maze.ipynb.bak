{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 596,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import random"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 597,
   "metadata": {},
   "outputs": [],
   "source": [
    "MAZE=[[0,0,1,1,1],\n",
    "      [0,1,1,0,1],\n",
    "      [1,1,1,0,1],\n",
    "      [1,0,1,0,1],\n",
    "      [1,0,1,1,1]]\n",
    "REWARDS_TABLE = [[0,0,1,1,1],\n",
    "                 [0,1,1,0,1],\n",
    "                 [1,1,1,0,1],\n",
    "                 [1,0,1,0,1],\n",
    "                 [100,0,1,1,1]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 598,
   "metadata": {},
   "outputs": [],
   "source": [
    "def init_state_table():\n",
    "    qtable = []\n",
    "    for row in range(len(MAZE)):\n",
    "        qtable_row = []\n",
    "        for column in range(len(MAZE[row])):\n",
    "            qtable_row.append(QEntry((row, column)))\n",
    "        qtable.append(qtable_row)\n",
    "    return qtable\n",
    "            \n",
    "\n",
    "class QEntry:\n",
    "    def __init__(self, state):\n",
    "        self.state = state\n",
    "        self.up = 0\n",
    "        self.down = 0\n",
    "        self.left = 0\n",
    "        self.right = 0\n",
    "        self.q_score = 0\n",
    "    \n",
    "    def get_state(self):\n",
    "        return self.state\n",
    "    def get_positions(self):\n",
    "        return {\"up\": self.up, \"down\": self.down, \"left\": self.left, \"right\": self.right}\n",
    "    def get_qscore(self):\n",
    "        return self.q_score\n",
    "\n",
    "    def update_positions(self, new_positions):\n",
    "        for key, value in new_positions.values():\n",
    "            pass\n",
    "    def update_qscore(self, new_val):\n",
    "        self.q_score = new_val\n",
    "            \n",
    "\n",
    "# Init Q-Table\n",
    "q_table = init_state_table()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 606,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[<__main__.QEntry at 0x22f60d844f0>,\n",
       "  <__main__.QEntry at 0x22f60d876a0>,\n",
       "  <__main__.QEntry at 0x22f60d857b0>,\n",
       "  <__main__.QEntry at 0x22f60d85990>,\n",
       "  <__main__.QEntry at 0x22f60d85510>],\n",
       " [<__main__.QEntry at 0x22f60d85210>,\n",
       "  <__main__.QEntry at 0x22f60d84850>,\n",
       "  <__main__.QEntry at 0x22f60d85330>,\n",
       "  <__main__.QEntry at 0x22f60d85660>,\n",
       "  <__main__.QEntry at 0x22f60d85600>],\n",
       " [<__main__.QEntry at 0x22f60d86e00>,\n",
       "  <__main__.QEntry at 0x22f60d86f50>,\n",
       "  <__main__.QEntry at 0x22f60d86dd0>,\n",
       "  <__main__.QEntry at 0x22f60d86ce0>,\n",
       "  <__main__.QEntry at 0x22f60d86d70>],\n",
       " [<__main__.QEntry at 0x22f60d86cb0>,\n",
       "  <__main__.QEntry at 0x22f60d84d60>,\n",
       "  <__main__.QEntry at 0x22f60d85060>,\n",
       "  <__main__.QEntry at 0x22f60d864d0>,\n",
       "  <__main__.QEntry at 0x22f60d865c0>],\n",
       " [<__main__.QEntry at 0x22f60d860e0>,\n",
       "  <__main__.QEntry at 0x22f60d85750>,\n",
       "  <__main__.QEntry at 0x22f60d85150>,\n",
       "  <__main__.QEntry at 0x22f60d85ab0>,\n",
       "  <__main__.QEntry at 0x22f60d85ae0>]]"
      ]
     },
     "execution_count": 606,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "q_table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 599,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_possible_actions(row_index, column_index):    \n",
    "    possible = {\"up\": False, \"down\": False, \"right\": False, \"left\": False}\n",
    "    #possible = {\"up\": row_index != 0, \"down\": row_index != len(MAZE)-1, \"right\": column_index != 0, \"left\": column_index != len(MAZE[0])-1}    \n",
    "    dir_functions = {\"up\": (lambda: True if MAZE[row_index-1][column_index] == 1 and not row_index == 0 else False),\n",
    "                     \"down\": (lambda: True if MAZE[row_index+1][column_index] == 1 and not row_index == len(MAZE)-1 else False),\n",
    "                     \"right\": (lambda: True if MAZE[row_index][column_index+1] == 1 and not column_index == len(MAZE[row_index])-1 else False),\n",
    "                     \"left\": (lambda: True if MAZE[row_index][column_index-1] == 1 and not column_index == 0 else False)}\n",
    "    for dir,funct in dir_functions.items():\n",
    "        try:\n",
    "            possible[dir] = funct()\n",
    "        except: pass\n",
    "\n",
    "    return possible"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 600,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_next_move(dictionary):\n",
    "    true_keys = [key for key, value in dictionary.items() if value]\n",
    "    if not true_keys:\n",
    "        return None\n",
    "    return random.choice(true_keys)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 601,
   "metadata": {},
   "outputs": [],
   "source": [
    "def iterate_to_next_move(current_position, next_move):\n",
    "    '''\n",
    "    current_position: tuple (row_index, column_index)\n",
    "    '''\n",
    "    new_pos = [current_position[0], current_position[1]]\n",
    "    match next_move:\n",
    "        case \"up\":\n",
    "            new_pos[0] -= 1\n",
    "        case \"down\":\n",
    "            new_pos[0] += 1\n",
    "        case \"right\":\n",
    "            new_pos[1] += 1\n",
    "        case \"left\":\n",
    "            new_pos[1] -= 1\n",
    "        case _:\n",
    "            raise Exception(\"No possible moves at ${current_position}\")\n",
    "    \n",
    "    return tuple(new_pos)\n",
    "\n",
    "def get_next_move_qtable(current_state, dir):\n",
    "    '''\n",
    "    current_state: A tuple containing the coordinates to the old state, (row_index, column_index)\n",
    "    '''\n",
    "\n",
    "    next_state = list(current_state)\n",
    "    match dir:\n",
    "        case \"up\":\n",
    "            next_state[0] = current_state[0] - 1\n",
    "            next_state[1] = current_state[1]\n",
    "        case \"down\":\n",
    "            next_state[0] = current_state[0] + 1\n",
    "            next_state[1] = current_state[1]\n",
    "        case \"left\":\n",
    "            next_state[0] = current_state[0]\n",
    "            next_state[1] = current_state[1] - 1\n",
    "        case \"right\":\n",
    "            next_state[0] = current_state[0]\n",
    "            next_state[1] = current_state[1] + 1\n",
    "        case _:\n",
    "            raise Exception(\"Direction is invalid\")\n",
    "    next_state = tuple(next_state)\n",
    "        \n",
    "    # Find the entry in the q_table that contains the new state\n",
    "    return q_table[next_state[0]][next_state[1]]\n",
    "    # for i in range(len(q_table)):\n",
    "    #     # print(str(q_table[i].get_state()) + str(next_state))\n",
    "    #     if q_table[i].get_state() == next_state:\n",
    "    #         return q_table[i]\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 602,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Bellman Equation\n",
    "alpha = 0.6\n",
    "gamma = 0.7\n",
    "\n",
    "bellman_equation = lambda state, old, next : (1 - alpha) * old + alpha * (REWARDS_TABLE[state[0]][state[1]] + gamma * next)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 603,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"(0, 4){'up': 0, 'down': 0, 'left': 0, 'right': 0}{'up': False, 'down': True, 'right': False, 'left': True} down\""
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "{'up': 0, 'down': 0, 'left': 0, 'right': 0}"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "'(1, 4) 0'"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Moving through the maze\n",
    "start_row_index, start_column_index = 0,4\n",
    "end_row_index, end_column_index = 4,0\n",
    "\n",
    "current_row_index, current_column_index = start_row_index, start_column_index\n",
    "\n",
    "# while True:\n",
    "# Get current state\n",
    "entry = q_table[current_row_index][current_column_index]\n",
    "state = entry.get_state()\n",
    "state_q_positions = entry.get_positions()\n",
    "possible_movements = get_possible_actions(state[0], state[1])\n",
    "\n",
    "# Get next move\n",
    "next_move = get_next_move(possible_movements)\n",
    "display(str(state) + str(state_q_positions) + str(possible_movements) + \" \" + str(next_move))\n",
    "\n",
    "# Get new state\n",
    "# next_state = iterate_to_next_move(state, get_next_move(possible_movements))\n",
    "# next_entry = q_table[next_state[0]][next_state[1]]\n",
    "# display(str(next_state) + str(next_entry.get_state()))\n",
    "display(state_q_positions)\n",
    "# Using Bellman equation to find the Q-values\n",
    "old = state_q_positions[next_move]\n",
    "next_q_obj = get_next_move_qtable(state, next_move)\n",
    "next_q = max(list(next_q_obj.get_positions().values()))\n",
    "display(str(next_q_obj.get_state()) + \" \" + str(next_q))\n",
    "# q_table[state[0]][state[1]]. += bellman_equation(state, old, next_q)\n",
    "\n",
    "    # if "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 604,
   "metadata": {},
   "outputs": [],
   "source": [
    "# MAZE=[[0,0,1,1,1],\n",
    "#       [0,1,1,0,1],\n",
    "#       [1,1,1,0,1],\n",
    "#       [1,0,1,0,1],\n",
    "#       [1,0,1,1,1]]\n",
    "#REWARDS_TABLE = [[0,0,1,1,1],\n",
    "#                 [0,1,1,0,1],\n",
    "#                 [1,1,1,0,1],\n",
    "#                 [1,0,1,0,1],\n",
    "#                 [100,0,1,1,1]]\n",
    "\n",
    "# for entry in q_table:\n",
    "#     state = entry.get_state()\n",
    "#     state_movements = entry.get_positions()\n",
    "    \n",
    "#     possible_movements = get_possible_actions(state[0], state[1])\n",
    "#     display(str(possible_movements) + str(next_move(possible_movements)))\n",
    "    # for key, value in possible_movements.items():\n",
    "    #     if value == True:\n",
    "        # old = state_movements[key]\n",
    "        # get_possible_actions(state, key)\n",
    "        # next_q_obj = get_next_move_qtable(state, key)\n",
    "        # next_q = max(list(next_q_obj.get_positions().values()))\n",
    "        # state_movements[key] = bellman_equation(state, old, next_q)\n",
    "\n",
    "#     display(str(state) + str(state_movements))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 605,
   "metadata": {},
   "outputs": [],
   "source": [
    "# get_possible_actions(2,1)\n",
    "# \n",
    "\n",
    "# bellman_equation = lambda alpha, gamma, reward : (1 - alpha) * q(s,a) + alpha * (reward + gamma * max(q'))\n",
    "\n",
    "# bellman_equation = lambda alpha, gamma, reward : (1 - alpha) * q(s,a) + alpha * (reward + gamma * max(q'))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "dsvenv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.10"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
